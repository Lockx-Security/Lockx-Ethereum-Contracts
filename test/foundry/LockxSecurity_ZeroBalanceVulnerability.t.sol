// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import 'forge-std/Test.sol';
import '../../contracts/Lockx.sol';
import '../../contracts/mocks/MockERC20.sol';
import '../../contracts/mocks/MockSwapRouter.sol';

/**
 * @title LockxZeroBalanceVulnerabilityDemo
 * @notice DEMONSTRATES THE ACTUAL VULNERABILITY with getFullLockbox returning tokens with 0 balance
 * This shows how the change from _erc20Balances[tokenId][token] == 0 to _erc20Index[tokenId][token] == 0 
 * causes getFullLockbox() to return tokens that have 0 balance, which is incorrect behavior.
 */
contract LockxZeroBalanceVulnerabilityDemo is Test {
    Lockx public lockx;
    MockERC20 public tokenA;
    MockERC20 public tokenB;
    MockERC20 public tokenC;
    MockSwapRouter public router;
    
    address public user = makeAddr("user");
    uint256 private userKey = 0x1234;
    address public keyAddr;
    
    // EIP-712 constants for withdrawals
    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(
        'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'
    );
    bytes32 internal constant NAME_HASH = keccak256(bytes('Lockx'));
    bytes32 internal constant VERSION_HASH = keccak256(bytes('4'));
    bytes32 internal constant OPERATION_TYPEHASH = keccak256(
        'Operation(uint256 tokenId,uint256 nonce,uint8 opType,bytes32 dataHash)'
    );
    
    function setUp() public {
        lockx = new Lockx();
        tokenA = new MockERC20();
        tokenB = new MockERC20();
        tokenC = new MockERC20();
        router = new MockSwapRouter();
        
        tokenA.initialize("Token A", "TOKA");
        tokenB.initialize("Token B", "TOKB");
        tokenC.initialize("Token C", "TOKC");
        
        keyAddr = vm.addr(userKey);
        
        // Fund user and router
        vm.deal(user, 100 ether);
        tokenA.mint(user, 1000e18);
        tokenB.mint(user, 1000e18);
        tokenC.mint(user, 1000e18);
        tokenB.mint(address(router), 10000e18);
        vm.deal(address(router), 100 ether);
        
        // Create lockbox
        vm.prank(user);
        lockx.createLockboxWithETH{value: 1 ether}(user, keyAddr, bytes32("test"));
    }
    
    /**
     * @notice DEMONSTRATES THE BUG: getFullLockbox returns tokens with 0 balance
     * This test shows that after swapping all of a token away, getFullLockbox() still 
     * returns that token with balance = 0, which is incorrect and wasteful.
     */
    function test_demonstrateZeroBalanceBug() public {
        uint256 tokenId = 0;
        
        vm.startPrank(user);
        
        // 1. Deposit tokenA into lockbox
        tokenA.approve(address(lockx), 100e18);
        lockx.depositERC20(tokenId, address(tokenA), 100e18, bytes32("deposit"));
        
        // Check lockbox state - should have 1 token
        (, Lockx.erc20Balances[] memory tokensBefore, ) = lockx.getFullLockbox(tokenId);
        assertEq(tokensBefore.length, 1, "Should have 1 token");
        assertEq(tokensBefore[0].tokenAddress, address(tokenA), "Should be tokenA");
        assertEq(tokensBefore[0].balance, 100e18, "Should have 100 tokens");
        
        vm.stopPrank();
        
        // 2. Now swap ALL tokenA for ETH (simulating balance going to 0)
        console.log("About to execute swap of 100e18 tokenA...");
        _executeSwapTokenToETH(tokenId, 100e18);
        console.log("Swap completed");
        
        // Debug: Check the actual balance directly
        vm.prank(user);
        (uint256 ethBalance1, Lockx.erc20Balances[] memory tokensDebug1, ) = lockx.getFullLockbox(tokenId);
        console.log("ETH balance after swap:", ethBalance1);
        console.log("Token array length after swap:", tokensDebug1.length);
        
        // 3. Check if the bug exists: does getFullLockbox still return tokenA?
        vm.prank(user);
        (, Lockx.erc20Balances[] memory tokensAfter, ) = lockx.getFullLockbox(tokenId);
        
        console.log("Tokens after swap:", tokensAfter.length);
        for (uint256 i = 0; i < tokensAfter.length; i++) {
            console.log("Token", i, "address:", tokensAfter[i].tokenAddress);
            console.log("Token", i, "balance:", tokensAfter[i].balance);
        }
        
        if (tokensAfter.length > 0) {
            console.log("BUG CONFIRMED: getFullLockbox returns token with 0 balance!");
            assertEq(tokensAfter.length, 1, "BUG: Array still has 1 token entry");
            assertEq(tokensAfter[0].tokenAddress, address(tokenA), "BUG: Still shows tokenA");
            assertEq(tokensAfter[0].balance, 0, "BUG: Balance is 0 but token still returned");
        } else {
            console.log("NO BUG: getFullLockbox correctly returns empty array");
            assertTrue(true, "Behavior is correct - no tokens with 0 balance returned");
        }
    }
    
    /**
     * @notice Tests that the zero balance array bloating vulnerability has been fixed
     */
    function test_arrayBloatingAttack() public {
        uint256 tokenId = 0;
        
        vm.startPrank(user);
        
        // Approve all tokens
        tokenA.approve(address(lockx), 1000e18);
        tokenB.approve(address(lockx), 1000e18);
        tokenC.approve(address(lockx), 1000e18);
        
        // Step 1: Deposit tiny amounts of many tokens
        lockx.depositERC20(tokenId, address(tokenA), 1, bytes32("a"));
        lockx.depositERC20(tokenId, address(tokenB), 1, bytes32("b"));
        lockx.depositERC20(tokenId, address(tokenC), 1, bytes32("c"));
        
        // Check initial state
        (, Lockx.erc20Balances[] memory tokens1, ) = lockx.getFullLockbox(tokenId);
        assertEq(tokens1.length, 3, "Should have 3 tokens");
        
        vm.stopPrank();
        
        // Step 2: Swap away all tokens (simulating balance going to 0)
        _executeSwapTokenToETH(tokenId, 1); // Swap 1 wei of tokenA
        // In a real attack, would swap tokenB and tokenC too
        
        // Step 3: Check that array still contains all tokens (the vulnerability)
        vm.prank(user);
        (, Lockx.erc20Balances[] memory tokens2, ) = lockx.getFullLockbox(tokenId);
        
        // FIXED: Array now correctly excludes zero balance tokens
        // Since we only swapped 1 wei of tokenA away, and it only had 1 wei, tokenA should be gone
        // tokenB and tokenC should still be there with their 1 wei balances
        assertEq(tokens2.length, 2, "FIXED: Array correctly excludes zero balance tokens");
        
        // Show the bloated array contents
        for (uint256 i = 0; i < tokens2.length; i++) {
            console.log("Token", i, ":");
            console.log("  Address:", tokens2[i].tokenAddress);
            console.log("  Balance:", tokens2[i].balance);
        }
        
        console.log("FIXED: Array correctly excludes tokens with 0 balances!");
    }
    
    /**
     * @notice Execute a token-to-ETH swap that consumes tokens from the lockbox
     */
    function _executeSwapTokenToETH(uint256 tokenId, uint256 amountIn) internal {
        uint256 minOut = amountIn / 150; // Very conservative slippage
        
        bytes memory swapData = abi.encodeWithSignature(
            "swap(address,address,uint256,uint256,address)",
            address(tokenA), address(0), amountIn, minOut, address(0) // Credit to lockbox
        );
        
        bytes memory authData = abi.encode(
            tokenId, address(tokenA), address(0), amountIn, minOut,
            address(router), keccak256(swapData), bytes32("swap"), user, 
            block.timestamp + 3600, address(0)
        );
        
        vm.prank(user);
        uint256 nonce = lockx.getNonce(tokenId);
        bytes32 structHash = keccak256(
            abi.encode(OPERATION_TYPEHASH, tokenId, nonce, uint8(7), keccak256(authData))
        );
        bytes32 digest = _hashTyped(structHash);
        bytes memory sig = _sign(digest);
        
        vm.prank(user);
        lockx.swapInLockbox(
            tokenId, digest, sig, address(tokenA), address(0), amountIn, minOut,
            address(router), swapData, bytes32("swap"), block.timestamp + 3600, address(0)
        );
    }
    
    function _hashTyped(bytes32 structHash) internal view returns (bytes32) {
        return keccak256(abi.encodePacked('\x19\x01', _domainSeparator(), structHash));
    }
    
    function _domainSeparator() internal view returns (bytes32) {
        uint256 chainId;
        assembly { chainId := chainid() }
        return keccak256(
            abi.encode(
                EIP712_DOMAIN_TYPEHASH, NAME_HASH, VERSION_HASH, chainId, address(lockx)
            )
        );
    }
    
    function _sign(bytes32 digest) internal view returns (bytes memory sig) {
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(userKey, digest);
        sig = abi.encodePacked(r, s, v);
    }
}