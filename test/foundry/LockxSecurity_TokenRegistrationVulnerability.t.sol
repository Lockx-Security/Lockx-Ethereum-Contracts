// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import 'forge-std/Test.sol';
import '../../contracts/Lockx.sol';
import '../../contracts/mocks/MockERC20.sol';

/**
 * @title LockxTokenRegistrationVulnerability
 * @notice Test the potential vulnerability in token registration logic change
 * from _erc20Balances[tokenId][token] == 0 to _erc20Index[tokenId][token] == 0
 */
contract LockxTokenRegistrationVulnerability is Test {
    Lockx public lockx;
    MockERC20 public tokenA;
    MockERC20 public tokenB;
    MockERC20 public tokenC;
    
    address public user = makeAddr("user");
    uint256 private userKey = 0x1234;
    address public keyAddr;
    
    function setUp() public {
        lockx = new Lockx();
        tokenA = new MockERC20();
        tokenB = new MockERC20();
        tokenC = new MockERC20();
        
        tokenA.initialize("Token A", "TOKA");
        tokenB.initialize("Token B", "TOKB");
        tokenC.initialize("Token C", "TOKC");
        
        keyAddr = vm.addr(userKey);
        
        // Fund user
        vm.deal(user, 100 ether);
        tokenA.mint(user, 1000e18);
        tokenB.mint(user, 1000e18);
        tokenC.mint(user, 1000e18);
        
        // Create lockbox
        vm.prank(user);
        lockx.createLockboxWithETH{value: 1 ether}(user, keyAddr, bytes32("test"));
    }
    
    function test_arrayPollutionAttack() public {
        uint256 tokenId = 0;
        
        vm.startPrank(user);
        
        // 1. Deposit tiny amounts of many different tokens
        tokenA.approve(address(lockx), 1000e18);
        tokenB.approve(address(lockx), 1000e18);
        tokenC.approve(address(lockx), 1000e18);
        
        lockx.depositERC20(tokenId, address(tokenA), 1, bytes32("a"));
        lockx.depositERC20(tokenId, address(tokenB), 1, bytes32("b"));
        lockx.depositERC20(tokenId, address(tokenC), 1, bytes32("c"));
        
        // Check initial state
        (uint256 ethBalance, , ) = lockx.getFullLockbox(tokenId);
        assertTrue(ethBalance > 0, "Should have ETH");
        
        vm.stopPrank();
        
        // 2. Somehow withdraw all tokens (simulating balance going to 0)
        // For testing, let's deposit more and then withdraw to see the behavior
        // This tests the vulnerability: do tokens with 0 balance stay in getFullLockbox()?
        
        assertTrue(true, "Array pollution test - need to extend with actual withdrawal");
    }
    
    function test_getFullLockboxWithZeroBalances() public {
        uint256 tokenId = 0;
        
        vm.startPrank(user);
        
        // Deposit and then withdraw tokens to create 0 balance entries
        tokenA.approve(address(lockx), 1000e18);
        lockx.depositERC20(tokenId, address(tokenA), 100e18, bytes32("test"));
        
        // Get lockbox state after deposit
        (, Lockx.erc20Balances[] memory tokens, ) = lockx.getFullLockbox(tokenId);
        assertEq(tokens.length, 1, "Should have 1 token");
        assertEq(tokens[0].balance, 100e18, "Should have 100 tokens");
        
        vm.stopPrank();
        
        // TODO: Need to test what happens after withdrawal brings balance to 0
        // The current implementation will likely still show the token with balance 0
        // This is the vulnerability we need to test and fix
    }
    
    function test_tokenRegistrationBehaviorChange() public {
        uint256 tokenId = 0;
        
        vm.startPrank(user);
        tokenA.approve(address(lockx), 1000e18);
        
        // First deposit - should register token
        lockx.depositERC20(tokenId, address(tokenA), 100e18, bytes32("first"));
        
        (, Lockx.erc20Balances[] memory tokens1, ) = lockx.getFullLockbox(tokenId);
        assertEq(tokens1.length, 1, "Should have 1 token after first deposit");
        assertEq(tokens1[0].balance, 100e18, "Should have 100 tokens");
        
        // Second deposit - should NOT re-register (this is where behavior changed)
        lockx.depositERC20(tokenId, address(tokenA), 50e18, bytes32("second"));
        
        (, Lockx.erc20Balances[] memory tokens2, ) = lockx.getFullLockbox(tokenId);
        assertEq(tokens2.length, 1, "Should still have 1 token entry");
        assertEq(tokens2[0].balance, 150e18, "Should have 150 tokens total");
        
        vm.stopPrank();
        
        // The question is: what happens if balance goes to 0 and then we deposit again?
        // Old logic: would re-register (index gets reset)
        // New logic: won't re-register (index persists)
        // Need withdrawal functionality to test this properly
    }
    
    function test_multipleTokensWithSomeZeroBalances() public {
        uint256 tokenId = 0;
        
        vm.startPrank(user);
        
        // Approve all tokens
        tokenA.approve(address(lockx), 1000e18);
        tokenB.approve(address(lockx), 1000e18);
        tokenC.approve(address(lockx), 1000e18);
        
        // Deposit multiple tokens
        lockx.depositERC20(tokenId, address(tokenA), 100e18, bytes32("a"));
        lockx.depositERC20(tokenId, address(tokenB), 200e18, bytes32("b"));
        lockx.depositERC20(tokenId, address(tokenC), 300e18, bytes32("c"));
        
        // Check all tokens are registered
        (, Lockx.erc20Balances[] memory tokens, ) = lockx.getFullLockbox(tokenId);
        assertEq(tokens.length, 3, "Should have 3 tokens");
        
        // Find tokenA in the array
        bool foundTokenA = false;
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokens[i].tokenAddress == address(tokenA)) {
                assertEq(tokens[i].balance, 100e18, "TokenA should have 100 tokens");
                foundTokenA = true;
                break;
            }
        }
        assertTrue(foundTokenA, "TokenA should be found in getFullLockbox");
        
        vm.stopPrank();
        
        // TODO: Test scenario where tokenA balance goes to 0 but stays in array
        // This would happen after withdrawal functionality is tested
    }
}