// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../../contracts/Lockx.sol";
import "../../contracts/mocks/MockERC20.sol";

contract AttackVulnerabilityTest is Test {
    Lockx public lockx;
    MockERC20 public token;
    
    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");
    uint256 public attackerPrivateKey = 0x1234;
    address public attackerPublicKey;
    
    function setUp() public {
        // Deploy contracts
        lockx = new Lockx();
        token = new MockERC20();
        token.initialize("Test Token", "TEST");
        
        // Setup attacker wallet
        attackerPublicKey = vm.addr(attackerPrivateKey);
        
        // Give tokens to victim and attacker
        token.mint(victim, 1000e18);
        token.mint(attacker, 1);
        token.mint(address(lockx), 1000e18); // Simulate the contract holding tokens
    }
    
    function testApprovalAttackBlocked() public {
        // 1. Attacker creates a lockbox with minimal tokens
        vm.startPrank(attacker);
        token.approve(address(lockx), 1);
        lockx.createLockboxWithERC20(attacker, attackerPublicKey, address(token), 1, bytes32(0));
        uint256 tokenId = 0; // First token ID
        vm.stopPrank();
        
        // 2. Attacker tries to use swapInLockbox to approve themselves max tokens
        vm.startPrank(attacker);
        
        // Build attack data: token.approve(attacker, type(uint256).max)
        bytes memory attackData = abi.encodeWithSelector(
            token.approve.selector, 
            attacker, 
            type(uint256).max
        );
        
        // Build signature for the swap
        uint256 nonce = lockx.getNonce(tokenId);
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Operation(uint256 tokenId,uint256 nonce,uint8 opType,bytes32 dataHash)"),
                tokenId,
                nonce,
                uint8(7), // SWAP_ASSETS
                keccak256(abi.encode(
                    tokenId,
                    address(token), // tokenIn
                    address(0),     // tokenOut (ETH)
                    1,              // amountIn
                    0,              // minAmountOut
                    address(token), // target - THIS IS THE KEY: targeting the token contract
                    keccak256(attackData),
                    bytes32(0),     // referenceId
                    attacker,       // msg.sender
                    block.timestamp + 1000, // signatureExpiry
                    attacker        // recipient
                ))
            )
        );
        
        bytes32 domainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes("Lockx")),
                keccak256(bytes("4")),
                block.chainid,
                address(lockx)
            )
        );
        
        bytes32 messageHash = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(attackerPrivateKey, messageHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // 3. Try to execute the attack - should revert with UnauthorizedRouter
        vm.expectRevert("UnauthorizedRouter()");
        lockx.swapInLockbox(
            tokenId,
            messageHash,
            signature,
            address(token), // tokenIn
            address(0),     // tokenOut  
            1,              // amountIn
            0,              // minAmountOut
            address(token), // target - the token contract itself
            attackData,     // malicious approve call
            bytes32(0),     // referenceId
            block.timestamp + 1000, // signatureExpiry
            attacker        // recipient
        );
        
        vm.stopPrank();
        
        // 4. Verify the attack failed - attacker should have no allowance
        assertEq(token.allowance(address(lockx), attacker), 0, "Attack should have been blocked");
    }
    
    function testDirectApprovalCallBlocked() public {
        // Test that even if we try to call a different contract that isn't tracked,
        // the selector blocking should still prevent approve calls
        
        // Deploy a second token that the contract doesn't hold
        MockERC20 anotherToken = new MockERC20();
        anotherToken.initialize("Another Token", "OTHER");
        
        vm.startPrank(attacker);
        token.approve(address(lockx), 1);
        lockx.createLockboxWithERC20(attacker, attackerPublicKey, address(token), 1, bytes32(0));
        uint256 tokenId = 0;
        vm.stopPrank();
        
        vm.startPrank(attacker);
        
        // Try to call approve on a different token (not tracked by the contract)
        bytes memory attackData = abi.encodeWithSelector(
            anotherToken.approve.selector,
            attacker,
            type(uint256).max
        );
        
        uint256 nonce = lockx.getNonce(tokenId);
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Operation(uint256 tokenId,uint256 nonce,uint8 opType,bytes32 dataHash)"),
                tokenId,
                nonce,
                uint8(7), // SWAP_ASSETS
                keccak256(abi.encode(
                    tokenId,
                    address(token),        // tokenIn
                    address(anotherToken), // tokenOut
                    1,                     // amountIn
                    0,                     // minAmountOut
                    address(anotherToken), // target
                    keccak256(attackData),
                    bytes32(0),
                    attacker,
                    block.timestamp + 1000,
                    attacker
                ))
            )
        );
        
        bytes32 domainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes("Lockx")),
                keccak256(bytes("4")),
                block.chainid,
                address(lockx)
            )
        );
        
        bytes32 messageHash = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(attackerPrivateKey, messageHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Should still be blocked by selector filtering
        vm.expectRevert("UnauthorizedRouter()");
        lockx.swapInLockbox(
            tokenId,
            messageHash,
            signature,
            address(token),        // tokenIn
            address(anotherToken), // tokenOut
            1,                     // amountIn
            0,                     // minAmountOut
            address(anotherToken), // target
            attackData,
            bytes32(0),
            block.timestamp + 1000,
            attacker
        );
        
        vm.stopPrank();
    }
}