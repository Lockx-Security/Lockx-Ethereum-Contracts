// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../../contracts/Lockx.sol";
import "../../contracts/mocks/MockERC20.sol";

contract VulnerabilityFixConfirmation is Test {
    Lockx public lockx;
    MockERC20 public token;
    
    address public attacker = makeAddr("attacker");
    uint256 public attackerPrivateKey = 0x1234;
    address public attackerPublicKey;
    
    function setUp() public {
        lockx = new Lockx();
        token = new MockERC20();
        token.initialize("Test Token", "TEST");
        
        attackerPublicKey = vm.addr(attackerPrivateKey);
        token.mint(attacker, 1000e18);
        token.mint(address(lockx), 1000e18);
    }
    
    function testSelectorExtractionNowWorks() public {
        // This test confirms the fix - selector extraction should now work properly
        
        vm.startPrank(attacker);
        token.approve(address(lockx), 1);
        lockx.createLockboxWithERC20(attacker, attackerPublicKey, address(token), 1, bytes32(0));
        uint256 tokenId = 0;
        
        // Build the approval attack that should now be blocked
        bytes memory approveData = abi.encodeWithSelector(
            token.approve.selector,
            attacker,
            type(uint256).max
        );
        
        console.log("Approve selector:", vm.toString(token.approve.selector));
        console.log("First 4 bytes of approveData:");
        console.logBytes4(bytes4(approveData));
        
        // Confirm the selector extraction now works
        bytes4 extractedSelector = bytes4(approveData[:4]);
        assertEq(extractedSelector, token.approve.selector, "Selector extraction should work correctly now");
        
        // Build signature for swap
        uint256 nonce = lockx.getNonce(tokenId);
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Operation(uint256 tokenId,uint256 nonce,uint8 opType,bytes32 dataHash)"),
                tokenId, nonce, uint8(7),
                keccak256(abi.encode(
                    tokenId, address(token), address(0), 1, 0,
                    address(token), keccak256(approveData), bytes32(0),
                    attacker, block.timestamp + 1000, attacker
                ))
            )
        );
        
        bytes32 domainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes("Lockx")), keccak256(bytes("4")), block.chainid, address(lockx)
            )
        );
        
        bytes32 messageHash = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(attackerPrivateKey, messageHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // The attack should now be properly blocked
        vm.expectRevert("UnauthorizedRouter()");
        lockx.swapInLockbox(
            tokenId, messageHash, signature, address(token), address(0), 1, 0,
            address(token), approveData, bytes32(0), block.timestamp + 1000, attacker
        );
        
        vm.stopPrank();
        
        // Verify the attack was blocked - no allowance should be set
        assertEq(token.allowance(address(lockx), attacker), 0, "Attack should be blocked by selector filtering");
        
        console.log("✅ Vulnerability fix confirmed - approval attack is now properly blocked");
    }
    
    function testOtherDangerousSelectorsBlocked() public {
        vm.startPrank(attacker);
        token.approve(address(lockx), 1);
        lockx.createLockboxWithERC20(attacker, attackerPublicKey, address(token), 1, bytes32(0));
        uint256 tokenId = 0;
        
        // Test transfer selector
        bytes memory transferData = abi.encodeWithSelector(
            token.transfer.selector,
            attacker,
            1000e18
        );
        
        bytes4 transferSelector = bytes4(transferData[:4]);
        assertEq(transferSelector, token.transfer.selector, "Transfer selector extraction works");
        
        uint256 nonce = lockx.getNonce(tokenId);
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Operation(uint256 tokenId,uint256 nonce,uint8 opType,bytes32 dataHash)"),
                tokenId, nonce, uint8(7),
                keccak256(abi.encode(
                    tokenId, address(token), address(0), 1, 0,
                    address(token), keccak256(transferData), bytes32(0),
                    attacker, block.timestamp + 1000, attacker
                ))
            )
        );
        
        bytes32 domainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes("Lockx")), keccak256(bytes("4")), block.chainid, address(lockx)
            )
        );
        
        bytes32 messageHash = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(attackerPrivateKey, messageHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Transfer should also be blocked
        vm.expectRevert("UnauthorizedRouter()");
        lockx.swapInLockbox(
            tokenId, messageHash, signature, address(token), address(0), 1, 0,
            address(token), transferData, bytes32(0), block.timestamp + 1000, attacker
        );
        
        vm.stopPrank();
        console.log("✅ Transfer selector also properly blocked");
    }
}