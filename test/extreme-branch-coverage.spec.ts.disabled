import { expect } from 'chai';
import { ethers } from 'hardhat';

describe('ðŸ”¥ EXTREME BRANCH COVERAGE - PUSH TO 92%+', () => {
  let lockx, mockToken, mockTokenB, mockRouter, mockNft, feeToken, usdtToken;
  let owner, user1, user2, keyPair;

  beforeEach(async () => {
    [owner, user1, user2] = await ethers.getSigners();
    keyPair = ethers.Wallet.createRandom();

    const Lockx = await ethers.getContractFactory('Lockx');
    lockx = await Lockx.deploy();

    const MockERC20 = await ethers.getContractFactory('MockERC20');
    mockToken = await MockERC20.deploy();
    await mockToken.initialize('TokenA', 'TKA');
    await mockToken.mint(user1.address, ethers.parseEther('50000'));
    await mockToken.connect(user1).approve(await lockx.getAddress(), ethers.MaxUint256);

    mockTokenB = await MockERC20.deploy();
    await mockTokenB.initialize('TokenB', 'TKB');
    await mockTokenB.mint(user1.address, ethers.parseEther('50000'));

    const USDTSimulator = await ethers.getContractFactory('USDTSimulator');
    usdtToken = await USDTSimulator.deploy();
    await usdtToken.mint(user1.address, ethers.parseEther('10000'));

    const FeeOnTransferToken = await ethers.getContractFactory('MockFeeOnTransferToken');
    feeToken = await FeeOnTransferToken.deploy();
    await feeToken.initialize('FeeToken', 'FEE');
    await feeToken.mint(user1.address, ethers.parseEther('10000'));
    await feeToken.connect(user1).approve(await lockx.getAddress(), ethers.MaxUint256);

    const MockERC721 = await ethers.getContractFactory('MockERC721');
    mockNft = await MockERC721.deploy();
    await mockNft.initialize('MockNFT', 'MNFT');
    for (let i = 1; i <= 20; i++) {
      await mockNft.connect(owner).mint(user1.address, i);
      await mockNft.connect(user1).approve(await lockx.getAddress(), i);
    }

    const MockSwapRouter = await ethers.getContractFactory('MockSwapRouter');
    mockRouter = await MockSwapRouter.deploy();
    await mockTokenB.mint(await mockRouter.getAddress(), ethers.parseEther('1000000'));
    await mockTokenB.connect(owner).approve(await mockRouter.getAddress(), ethers.MaxUint256);
    await owner.sendTransaction({
      to: await mockRouter.getAddress(),
      value: ethers.parseEther('1')
    });

    // Create treasury lockbox (ID 0)
    await lockx.connect(owner).createLockboxWithETH(
      owner.address,
      ethers.Wallet.createRandom().address,
      ethers.ZeroHash,
      { value: ethers.parseEther('0.001') }
    );
  });

  it('should hit EXTREME batchWithdraw edge cases', async () => {
    console.log('ðŸ”¥ EXTREME: Targeting MAXIMUM batchWithdraw branches');
    
    // Create super complex lockbox with MANY assets
    const manyTokens = [await mockToken.getAddress(), await feeToken.getAddress(), await usdtToken.getAddress()];
    const manyAmounts = [ethers.parseEther('1000'), ethers.parseEther('500'), ethers.parseEther('200')];
    const manyNftContracts = [await mockNft.getAddress(), await mockNft.getAddress(), await mockNft.getAddress()];
    const manyNftIds = [10, 11, 12];

    await usdtToken.connect(user1).approve(await lockx.getAddress(), ethers.MaxUint256);
    await lockx.connect(user1).createLockboxWithBatch(
      user1.address,
      keyPair.address,
      ethers.parseEther('5'), // ETH amount
      manyTokens,
      manyAmounts,
      manyNftContracts,
      manyNftIds,
      ethers.ZeroHash,
      { value: ethers.parseEther('5') }
    );

    const tokenId = 1;
    const currentBlock = await ethers.provider.getBlock('latest');
    const signatureExpiry = currentBlock.timestamp + 3600;
    
    // EXTREME TEST 1: Withdraw multiple tokens but only SOME completely (mixed removal/update)
    let nonce = await lockx.connect(user1).getNonce(tokenId);
    let referenceId = ethers.keccak256(ethers.toUtf8Bytes('extreme_partial'));
    
    // Withdraw: partial mockToken, complete feeToken, partial usdtToken
    const partialWithdrawTokens = [await mockToken.getAddress(), await feeToken.getAddress(), await usdtToken.getAddress()];
    const partialWithdrawAmounts = [ethers.parseEther('300'), ethers.parseEther('500'), ethers.parseEther('100')];
    
    let withdrawData = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'uint256', 'address[]', 'uint256[]', 'address[]', 'uint256[]', 'address', 'bytes32', 'address', 'uint256'],
      [tokenId, ethers.parseEther('5'), partialWithdrawTokens, partialWithdrawAmounts, [], [], user2.address, referenceId, user1.address, signatureExpiry]
    );

    let domain = {
      name: 'Lockx',
      version: '4',
      chainId: (await ethers.provider.getNetwork()).chainId,
      verifyingContract: await lockx.getAddress()
    };

    let types = {
      Operation: [
        { name: 'tokenId', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'opType', type: 'uint8' },
        { name: 'dataHash', type: 'bytes32' }
      ]
    };

    let opValue = {
      tokenId,
      nonce,
      opType: 6, // BATCH_WITHDRAW
      dataHash: ethers.keccak256(withdrawData)
    };

    let signature = await keyPair.signTypedData(domain, types, opValue);
    let messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

    await lockx.connect(user1).batchWithdraw(
      tokenId,
      messageHash,
      signature,
      ethers.parseEther('5'), // ETH
      partialWithdrawTokens,
      partialWithdrawAmounts,
      [], // No NFTs this time
      [],
      user2.address,
      referenceId,
      signatureExpiry
    );
    console.log('âœ… EXTREME: Mixed partial/complete token withdrawals (multiple branches)');

    // EXTREME TEST 2: Multiple NFTs in one batch (test NFT loop branches)
    nonce = await lockx.connect(user1).getNonce(tokenId);
    referenceId = ethers.keccak256(ethers.toUtf8Bytes('extreme_nft_batch'));
    
    withdrawData = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'uint256', 'address[]', 'uint256[]', 'address[]', 'uint256[]', 'address', 'bytes32', 'address', 'uint256'],
      [tokenId, 0, [], [], [await mockNft.getAddress(), await mockNft.getAddress(), await mockNft.getAddress()], [10, 11, 12], user2.address, referenceId, user1.address, signatureExpiry]
    );

    opValue = {
      tokenId,
      nonce,
      opType: 6,
      dataHash: ethers.keccak256(withdrawData)
    };

    signature = await keyPair.signTypedData(domain, types, opValue);
    messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

    await lockx.connect(user1).batchWithdraw(
      tokenId,
      messageHash,
      signature,
      0, // No ETH
      [], // No tokens
      [],
      [await mockNft.getAddress(), await mockNft.getAddress(), await mockNft.getAddress()], // Multiple NFTs
      [10, 11, 12], // All NFT IDs
      user2.address,
      referenceId,
      signatureExpiry
    );
    console.log('âœ… EXTREME: Multiple NFT batch withdraw (NFT loop branches)');

    console.log('ðŸ”¥ EXTREME: MAXIMUM batchWithdraw branches systematically hit!');
  });

  it('should hit EXTREME swapInLockbox scenarios', async () => {
    console.log('ðŸ”¥ EXTREME: Targeting MAXIMUM swapInLockbox branches');
    
    // Create lockbox with many assets for complex swaps
    await mockToken.connect(user1).approve(await lockx.getAddress(), ethers.parseEther('5000'));
    await lockx.connect(user1).createLockboxWithBatch(
      user1.address,
      keyPair.address,
      ethers.parseEther('5'), // Large ETH
      [await mockToken.getAddress()],
      [ethers.parseEther('5000')],
      [],
      [],
      ethers.ZeroHash,
      { value: ethers.parseEther('5') }
    );

    const tokenId = 1;
    const currentBlock = await ethers.provider.getBlock('latest');
    const signatureExpiry = currentBlock.timestamp + 3600;

    // EXTREME TEST 1: Large ETH â†’ Token swap with high fees
    let referenceId = ethers.keccak256(ethers.toUtf8Bytes('extreme_eth_token'));
    let nonce = await lockx.connect(user1).getNonce(tokenId);
    
    let swapCallData = mockRouter.interface.encodeFunctionData('swapETHForTokens', [
      await mockTokenB.getAddress(),
      ethers.parseEther('4600'), // Expected (5 ETH * 950 = 4750)
      await lockx.getAddress()
    ]);

    let swapData = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'address', 'address', 'uint256', 'uint256', 'address', 'bytes32', 'bytes32', 'address', 'uint256', 'address'],
      [
        tokenId,
        ethers.ZeroAddress, // ETH in
        await mockTokenB.getAddress(), // Token out
        ethers.parseEther('5'), // ETH amount in
        ethers.parseEther('4600'), // Expected tokens out
        await mockRouter.getAddress(),
        ethers.keccak256(swapCallData),
        referenceId,
        user1.address,
        signatureExpiry,
        ethers.ZeroAddress // Credit to lockbox (new token registration)
      ]
    );

    let domain = {
      name: 'Lockx',
      version: '4',
      chainId: (await ethers.provider.getNetwork()).chainId,
      verifyingContract: await lockx.getAddress()
    };

    let types = {
      Operation: [
        { name: 'tokenId', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'opType', type: 'uint8' },
        { name: 'dataHash', type: 'bytes32' }
      ]
    };

    let opValue = {
      tokenId,
      nonce,
      opType: 7, // SWAP_ASSETS
      dataHash: ethers.keccak256(swapData)
    };

    let signature = await keyPair.signTypedData(domain, types, opValue);
    let messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

    await lockx.connect(user1).swapInLockbox(
      tokenId,
      messageHash,
      signature,
      ethers.ZeroAddress, // ETH in
      await mockTokenB.getAddress(),
      ethers.parseEther('5'), // ETH swap amount
      ethers.parseEther('4600'), // Min tokens out
      await mockRouter.getAddress(),
      swapCallData,
      referenceId,
      signatureExpiry,
      ethers.ZeroAddress // New token registration branch
    );
    console.log('âœ… EXTREME: Large ETHâ†’Token swap with new token registration');

    // EXTREME TEST 2: Large Token â†’ ETH swap with external recipient (fee branches)
    referenceId = ethers.keccak256(ethers.toUtf8Bytes('extreme_token_eth'));
    nonce = await lockx.connect(user1).getNonce(tokenId);

    swapCallData = mockRouter.interface.encodeFunctionData('swapTokensForETH', [
      await mockToken.getAddress(),
      ethers.parseEther('1000'),
      ethers.parseEther('0.0009'), // Realistic expectation from mock router
      user2.address // External recipient
    ]);

    swapData = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'address', 'address', 'uint256', 'uint256', 'address', 'bytes32', 'bytes32', 'address', 'uint256', 'address'],
      [
        tokenId,
        await mockToken.getAddress(),
        ethers.ZeroAddress, // ETH out
        ethers.parseEther('1000'),
        ethers.parseEther('0.0009'),
        await mockRouter.getAddress(),
        ethers.keccak256(swapCallData),
        referenceId,
        user1.address,
        signatureExpiry,
        user2.address // External recipient (not lockbox)
      ]
    );

    opValue = {
      tokenId,
      nonce,
      opType: 7,
      dataHash: ethers.keccak256(swapData)
    };

    signature = await keyPair.signTypedData(domain, types, opValue);
    messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

    await expect(
      lockx.connect(user1).swapInLockbox(
        tokenId,
        messageHash,
        signature,
        await mockToken.getAddress(),
        ethers.ZeroAddress, // ETH out
        ethers.parseEther('1000'),
        ethers.parseEther('0.0009'),
        await mockRouter.getAddress(),
        swapCallData,
        referenceId,
        signatureExpiry,
        user2.address // External recipient branch
      )
    ).to.be.revertedWithCustomError(lockx, 'SlippageExceeded');
    console.log('âœ… EXTREME: Large Tokenâ†’ETH swap with external recipient');

    // EXTREME TEST 3: Test token deduction that triggers balance cleanup
    referenceId = ethers.keccak256(ethers.toUtf8Bytes('extreme_cleanup'));
    nonce = await lockx.connect(user1).getNonce(tokenId);

    // First check remaining balance
    const lockboxData = await lockx.connect(user1).getFullLockbox(tokenId);
    const tokenAAddress = await mockToken.getAddress();
    const remainingTokenA = lockboxData[1].find(token => token.tokenAddress === tokenAAddress)?.balance || 0n;
    
    if (remainingTokenA > 0) {
      swapCallData = mockRouter.interface.encodeFunctionData('swap', [
        await mockToken.getAddress(),
        await mockTokenB.getAddress(),
        remainingTokenA, // Use ALL remaining tokens
        ethers.parseEther('1'), // Very low min to ensure success
        await lockx.getAddress()
      ]);

      swapData = ethers.AbiCoder.defaultAbiCoder().encode(
        ['uint256', 'address', 'address', 'uint256', 'uint256', 'address', 'bytes32', 'bytes32', 'address', 'uint256', 'address'],
        [
          tokenId,
          await mockToken.getAddress(),
          await mockTokenB.getAddress(),
          remainingTokenA,
          ethers.parseEther('1'),
          await mockRouter.getAddress(),
          ethers.keccak256(swapCallData),
          referenceId,
          user1.address,
          signatureExpiry,
          ethers.ZeroAddress
        ]
      );

      opValue = {
        tokenId,
        nonce,
        opType: 7,
        dataHash: ethers.keccak256(swapData)
      };

      signature = await keyPair.signTypedData(domain, types, opValue);
      messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

      await lockx.connect(user1).swapInLockbox(
        tokenId,
        messageHash,
        signature,
        await mockToken.getAddress(),
        await mockTokenB.getAddress(),
        remainingTokenA,
        ethers.parseEther('1'),
        await mockRouter.getAddress(),
        swapCallData,
        referenceId,
        signatureExpiry,
        ethers.ZeroAddress
      );
      console.log('âœ… EXTREME: Complete token balance cleanup in swap');
    }

    console.log('ðŸ”¥ EXTREME: MAXIMUM swapInLockbox branches systematically hit!');
  });

  it('should hit EXTREME individual withdrawal branches', async () => {
    console.log('ðŸ”¥ EXTREME: Targeting individual withdrawal branches');
    
    // Create lockbox with all asset types
    await mockToken.connect(user1).approve(await lockx.getAddress(), ethers.parseEther('1000'));
    await lockx.connect(user1).createLockboxWithBatch(
      user1.address,
      keyPair.address,
      ethers.parseEther('10'),
      [await mockToken.getAddress()],
      [ethers.parseEther('1000')],
      [await mockNft.getAddress()],
      [15],
      ethers.ZeroHash,
      { value: ethers.parseEther('10') }
    );

    const tokenId = 1;
    const currentBlock = await ethers.provider.getBlock('latest');
    const signatureExpiry = currentBlock.timestamp + 3600;

    // Test complete ETH withdrawal
    let nonce = await lockx.connect(user1).getNonce(tokenId);
    let referenceId = ethers.keccak256(ethers.toUtf8Bytes('complete_eth'));
    
    let withdrawData = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'uint256', 'address', 'bytes32', 'address', 'uint256'],
      [tokenId, ethers.parseEther('10'), user2.address, referenceId, user1.address, signatureExpiry]
    );

    let domain = {
      name: 'Lockx',
      version: '4',
      chainId: (await ethers.provider.getNetwork()).chainId,
      verifyingContract: await lockx.getAddress()
    };

    let types = {
      Operation: [
        { name: 'tokenId', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'opType', type: 'uint8' },
        { name: 'dataHash', type: 'bytes32' }
      ]
    };

    let opValue = {
      tokenId,
      nonce,
      opType: 1, // WITHDRAW_ETH
      dataHash: ethers.keccak256(withdrawData)
    };

    let signature = await keyPair.signTypedData(domain, types, opValue);
    let messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

    await lockx.connect(user1).withdrawETH(
      tokenId,
      messageHash,
      signature,
      ethers.parseEther('10'), // Complete ETH balance
      user2.address,
      referenceId,
      signatureExpiry
    );
    console.log('âœ… EXTREME: Complete ETH withdrawal');

    // Test partial ERC20 withdrawal (no cleanup)
    nonce = await lockx.connect(user1).getNonce(tokenId);
    referenceId = ethers.keccak256(ethers.toUtf8Bytes('partial_token'));
    
    withdrawData = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'address', 'uint256', 'address', 'bytes32', 'address', 'uint256'],
      [tokenId, await mockToken.getAddress(), ethers.parseEther('500'), user2.address, referenceId, user1.address, signatureExpiry]
    );

    opValue = {
      tokenId,
      nonce,
      opType: 2, // WITHDRAW_ERC20
      dataHash: ethers.keccak256(withdrawData)
    };

    signature = await keyPair.signTypedData(domain, types, opValue);
    messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

    await lockx.connect(user1).withdrawERC20(
      tokenId,
      messageHash,
      signature,
      await mockToken.getAddress(),
      ethers.parseEther('500'), // Partial amount
      user2.address,
      referenceId,
      signatureExpiry
    );
    console.log('âœ… EXTREME: Partial ERC20 withdrawal (no cleanup)');

    // Test complete ERC20 withdrawal (triggers cleanup)
    nonce = await lockx.connect(user1).getNonce(tokenId);
    referenceId = ethers.keccak256(ethers.toUtf8Bytes('complete_token'));
    
    withdrawData = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'address', 'uint256', 'address', 'bytes32', 'address', 'uint256'],
      [tokenId, await mockToken.getAddress(), ethers.parseEther('500'), user2.address, referenceId, user1.address, signatureExpiry]
    );

    opValue = {
      tokenId,
      nonce,
      opType: 2, // WITHDRAW_ERC20
      dataHash: ethers.keccak256(withdrawData)
    };

    signature = await keyPair.signTypedData(domain, types, opValue);
    messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

    await lockx.connect(user1).withdrawERC20(
      tokenId,
      messageHash,
      signature,
      await mockToken.getAddress(),
      ethers.parseEther('500'), // Complete remaining amount
      user2.address,
      referenceId,
      signatureExpiry
    );
    console.log('âœ… EXTREME: Complete ERC20 withdrawal (triggers cleanup)');

    // Test ERC721 withdrawal
    nonce = await lockx.connect(user1).getNonce(tokenId);
    referenceId = ethers.keccak256(ethers.toUtf8Bytes('nft_withdraw'));
    
    withdrawData = ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'address', 'uint256', 'address', 'bytes32', 'address', 'uint256'],
      [tokenId, await mockNft.getAddress(), 15, user2.address, referenceId, user1.address, signatureExpiry]
    );

    opValue = {
      tokenId,
      nonce,
      opType: 3, // WITHDRAW_ERC721
      dataHash: ethers.keccak256(withdrawData)
    };

    signature = await keyPair.signTypedData(domain, types, opValue);
    messageHash = ethers.TypedDataEncoder.hash(domain, types, opValue);

    await lockx.connect(user1).withdrawERC721(
      tokenId,
      messageHash,
      signature,
      await mockNft.getAddress(),
      15, // NFT ID
      user2.address,
      referenceId,
      signatureExpiry
    );
    console.log('âœ… EXTREME: ERC721 withdrawal');

    console.log('ðŸ”¥ EXTREME: ALL individual withdrawal branches systematically hit!');
  });

  it('should hit EXTREME deposit edge cases', async () => {
    console.log('ðŸ”¥ EXTREME: Targeting EXTREME deposit branches');
    
    // Create simple lockbox for additional deposits
    await lockx.connect(user1).createLockboxWithETH(
      user1.address,
      keyPair.address,
      ethers.ZeroHash,
      { value: ethers.parseEther('0.001') }
    );

    const tokenId = 1;

    // Test minimal deposits to hit edge branches
    await lockx.connect(user1).depositETH(
      tokenId,
      ethers.ZeroHash,
      { value: ethers.parseEther('0.0001') } // Very small amount
    );
    console.log('âœ… EXTREME: Minimal ETH deposit');

    // Test fee-on-transfer with various fee rates
    await feeToken.setFeePercentage(5000); // 50% fee
    await feeToken.connect(user1).approve(await lockx.getAddress(), ethers.parseEther('100'));
    await lockx.connect(user1).depositERC20(
      tokenId,
      await feeToken.getAddress(),
      ethers.parseEther('100'),
      ethers.ZeroHash
    );
    console.log('âœ… EXTREME: Fee-on-transfer deposit with 50% fee');

    // Test NFT deposit
    await lockx.connect(user1).depositERC721(
      tokenId,
      await mockNft.getAddress(),
      16, // New NFT
      ethers.ZeroHash
    );
    console.log('âœ… EXTREME: NFT deposit');

    // Test batchDeposit with maximum variety
    await mockToken.connect(user1).approve(await lockx.getAddress(), ethers.parseEther('200'));
    await usdtToken.connect(user1).approve(await lockx.getAddress(), ethers.parseEther('200'));
    
    await lockx.connect(user1).batchDeposit(
      tokenId,
      ethers.parseEther('0.5'), // More ETH
      [await mockToken.getAddress(), await usdtToken.getAddress()], // Multiple new tokens
      [ethers.parseEther('100'), ethers.parseEther('200')],
      [await mockNft.getAddress(), await mockNft.getAddress()], // Multiple NFTs
      [17, 18],
      ethers.ZeroHash,
      { value: ethers.parseEther('0.5') }
    );
    console.log('âœ… EXTREME: Maximum variety batchDeposit');

    console.log('ðŸ”¥ EXTREME: ALL extreme deposit branches systematically hit!');
  });
});