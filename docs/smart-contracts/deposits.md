# Deposits contract

`Deposits.sol` is a lean helper that accepts incoming assets so the main `Lockx` contract never needs token-specific code. It keeps the external surface small, emits clean events, and forwards everything to the system treasury (a minimal proxy owned by `Lockx`).

## Why separate deposits?

* Avoids sprinkling ERC-20/ERC-721 logic throughout the core.
* Lets auditors focus on a short, self-contained file.
* Gas-efficient: one storage write per deposit, no loops.

## Supported asset types

| Asset | Entry point | Notes |
|-------|-------------|-------|
| Native ETH | `receive()` or `depositETH()` | Emits `EthDeposited` | 
| ERC-20 | `depositToken(address token, uint256 amount)` | Requires `allowance` first | 
| ERC-721 | `onERC721Received()` (safe transfer) | Single tokenId | 
| ERC-1155 | `onERC1155Received()` | Batch sends are rejected to keep logic simple |

## Core events

```solidity
EthDeposited(address indexed from, uint256 value);
ERC20Deposited(address indexed from, address indexed token, uint256 value);
ERC721Deposited(address indexed from, address indexed token, uint256 id);
ERC1155Deposited(address indexed from, address indexed token, uint256 id, uint256 value);
```

Every event also includes the `key` generated by `Lockx` so indexers can link deposits to locks.

## Life-cycle

1. User calls `Lockx.lock()`.
2. `Lockx` validates parameters then forwards the asset transfer to `Deposits`.
3. `Deposits` pulls or receives the asset, emits the event, then returns `true`.
4. `Lockx` finalises the lock state.

The contract is **stateless** beyond events: if it is ever compromised the attacker cannot move funds, because ownership checks live in `Lockx`.
