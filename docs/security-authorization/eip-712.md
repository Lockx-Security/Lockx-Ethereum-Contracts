# EIP-712 signature schema

Lockx uses typed data to guarantee that wallets show **human-readable** fields before you sign.

## Domain separator

| Field | Value |
|-------|-------|
| name | `Lockx` |
| version | `1` |
| chainId | Current network id |
| verifyingContract | `0x…Lockx` |

`domainHash = keccak256(abi.encode(…))`

## Primary types

```solidity
struct WithdrawETH {
    uint256 tokenId;
    uint256 amountETH;
    address recipient;
    bytes32 referenceId;    // arbitrary tag
    uint256 nonce;          // auto-increment per Lockbox
    uint256 deadline;       // unix seconds
}
```

Each operation (`WithdrawERC20`, `RotateKey`, …) has its own struct and `TYPE_HASH`.

## Signing flow (MetaMask)

1. dApp shows modal with exact fields.  
2. Click “Sign” – MetaMask displays the same table.  
3. Confirm → `signature` (`r,s,v`) returned to the dApp.

MetaMask injects the domain automatically so the signature cannot be replayed on another chain or contract.

## Troubleshooting

* “Data hash does not match” → ensure you kept the same `nonce` and `deadline`.
* “Unknown type hash” → update to the latest contract ABI; new operations add new structs.

See [security measures](security-measures.md) for how nonces/deadlines prevent replay and MEV attacks.
